a = 0;  // 00000000000000000000000000000000
a = 1;  // 00000000000000000000000000000001
a = 2;  // 00000000000000000000000000000010
a = 3;  // 00000000000000000000000000000011
a = 255;// 00000000000000000000000011111111


// В следующей таблице перечислены все побитовые операторы. Далее операторы разобраны более подробно.
//
// Оператор	Использование	Описание
// Побитовое И (AND)	a & b	Ставит 1 на бит результата, для которого соответствующие биты операндов равны 1.
// Побитовое ИЛИ (OR)	a | b	Ставит 1 на бит результата, для которого хотя бы один из соответствующих битов операндов равен 1.
// Побитовое исключающее ИЛИ (XOR)	a ^ b	Ставит 1 на бит результата, для которого только один из соответствующих битов операндов равен 1 (но не оба).
// Побитовое НЕ (NOT)	~a	Заменяет каждый бит операнда на противоположный.
// Левый сдвиг	`a << b`	Сдвигает двоичное представление a на b битов влево, добавляя справа нули.
// Правый сдвиг, переносящий знак	`a >> b`	Сдвигает двоичное представление a на b битов вправо, отбрасывая сдвигаемые биты.
// Правый сдвиг с заполнением нулями	`a >>> b`	Сдвигает двоичное представление a на b битов вправо, отбрасывая сдвигаемые биты и добавляя нули слева.

// Побитовые операторы работают следующим образом:
//
// Операнды преобразуются в 32-битные целые числа, представленные последовательностью битов. Дробная часть, если она есть, отбрасывается.
// Для бинарных операторов – каждый бит в первом операнде рассматривается вместе с соответствующим битом второго операнда: первый бит с первым, второй со вторым и т.п. Оператор применяется к каждой паре бит, давая соответствующий бит результата.
// Получившаяся в результате последовательность бит интерпретируется как обычное число.

// Вспомогательные функции parseInt, toString
// Для удобной работы с примерами в этой статье, если вы захотите протестировать что-то в консоли, пригодятся две функции.

var access = parseInt("11000", 2); // получаем число из строки

alert( access ); // 24, число с таким 2-ным представлением

var access2 = access.toString(2); // обратно двоичную строку из числа

alert( access2 ); // 11000


// & (Побитовое И)
//
// Выполняет операцию И над каждой парой бит.
//
// Результат a & b равен единице только когда оба бита a и b равны единице.
//
// Таблица истинности для &:

// a	b	a & b
// 0	0	0
// 0	1	0
// 1	0	0
// 1	1	1

// Пример:
//
// 9 (по осн. 10)
//   = 00000000000000000000000000001001 (по осн. 2)
// 14 (по осн. 10)
//   = 00000000000000000000000000001110 (по осн. 2)
//                    --------------------------------
// 14 & 9 (по осн. 10)
//   = 00000000000000000000000000001000 (по осн. 2)
//   = 8 (по осн. 10)

// | (Побитовое ИЛИ)
//
// Выполняет операцию ИЛИ над каждой парой бит. Результат a | b равен 1, если хотя бы один бит из a,b равен 1.
//
// Таблица истинности для |:
//
// a	b	a | b
// 0	0	0
// 0	1	1
// 1	0	1
// 1	1	1

// Пример:
//
// 9 (по осн. 10)
//   = 00000000000000000000000000001001 (по осн. 2)
// 14 (по осн. 10)
//   = 00000000000000000000000000001110 (по осн. 2)
//                    --------------------------------
// 14 | 9 (по осн. 10)
//   = 00000000000000000000000000001111 (по осн. 2)
//   = 15 (по осн. 10)

// ^ (Исключающее ИЛИ)
//
// Выполняет операцию «Исключающее ИЛИ» над каждой парой бит.
//
// a Исключающее ИЛИ b равно 1, если только a=1 или только b=1, но не оба одновременно a=b=1.
//
// Таблица истинности для исключающего ИЛИ:
//
// a	b	a ^ b
// 0	0	0
// 0	1	1
// 1	0	1
// 1	1	0

// Как видно, оно даёт 1, если ЛИБО слева 1, ЛИБО справа 1, но не одновременно. Поэтому его и называют «исключающее ИЛИ».
//
// Пример:
//
// 9 (по осн. 10)
//   = 00000000000000000000000000001001 (по осн. 2)
// 14 (по осн. 10)
//   = 00000000000000000000000000001110 (по осн. 2)
//                    --------------------------------
// 14 ^ 9 (по осн. 10)
//   = 00000000000000000000000000000111 (по осн. 2)
//   = 7 (по осн. 10)


// Исключающее ИЛИ в шифровании
// Исключающее или можно использовать для шифрования, так как эта операция полностью обратима. Двойное применение исключающего ИЛИ с тем же аргументом даёт исходное число.
//
// Иначе говоря, верна формула: a ^ b ^ b == a.
//
// Пускай Вася хочет передать Пете секретную информацию data. Эта информация заранее превращена в число, например строка интерпретируется как последовательность кодов символов.
//
// Вася и Петя заранее договариваются о числовом ключе шифрования key.
//
// Алгоритм:
//
// Вася берёт двоичное представление data и делает операцию data ^ key. При необходимости data бьётся на части, равные по длине key, чтобы можно было провести побитовое ИЛИ ^ для каждой части. В JavaScript оператор ^ работает с 32-битными целыми числами, так что data нужно разбить на последовательность таких чисел.
// Результат data ^ key отправляется Пете, это шифровка.
// Например, пусть в data очередное число равно 9, а ключ key равен 1220461917.
//
// Данные: 9 в двоичном виде
// 00000000000000000000000000001001
//
// Ключ: 1220461917 в двоичном виде
// 01001000101111101100010101011101
//
// Результат операции 9 ^ key:
// 01001000101111101100010101010100
// Результат в 10-ной системе (шифровка):
// 1220461908
// Петя, получив очередное число шифровки 1220461908, применяет к нему такую же операцию ^ key.
// Результатом будет исходное число data.
// В нашем случае:
//
// Полученная шифровка в двоичной системе:
// 9 ^ key = 1220461908
// 01001000101111101100010101010100
//
// Ключ: 1220461917 в двоичном виде:
// 01001000101111101100010101011101
//
// Результат операции 1220461917 ^ key:
// 00000000000000000000000000001001
// Результат в 10-ной системе (исходное сообщение):
// 9
// Конечно, такое шифрование поддаётся частотному анализу и другим методам дешифровки, поэтому современные алгоритмы используют операцию XOR ^ как одну из важных частей более сложной многоступенчатой схемы.

// ~ (Побитовое НЕ)
//
// Производит операцию НЕ над каждым битом, заменяя его на обратный ему.
//
// Таблица истинности для НЕ:
//
// a	~a
// 0	1
// 1	0

// Пример:
//
//  9 (по осн. 10)
//   = 00000000000000000000000000001001 (по осн. 2)
//                --------------------------------
// ~9 (по осн. 10)
//   = 11111111111111111111111111110110 (по осн. 2)
//   = -10 (по осн. 10)

// Из-за внутреннего представления отрицательных чисел получается так, что ~n == -(n+1).
//
// Например:
//
alert( ~3 ); // -4
alert( ~-1 ); // 0

// << (Битовый сдвиг влево)
//
// Операторы битового сдвига принимают два операнда. Первый – это число для сдвига, а второй – количество битов, которые нужно сдвинуть в первом операнде.
//
// Оператор << сдвигает первый операнд на указанное число битов влево. Лишние биты отбрасываются, справа добавляются нулевые биты.
//
// Например, 9 << 2 даст 36:
//
// 9 (по осн.10)
//   = 00000000000000000000000000001001 (по осн.2)
//                   --------------------------------
// 9 << 2 (по осн.10)
//   = 00000000000000000000000000100100 (по осн.2)
//   = 36 (по осн.10)
// Операция << 2 сдвинула и отбросила два левых нулевых бита и добавила справа два новых нулевых.


// Левый сдвиг почти равен умножению на 2
// Битовый сдвиг << N обычно имеет тот же эффект, что и умножение на два N раз, например:

alert( 3 << 1 ); // 6, умножение на 2
alert( 3 << 2 ); // 12, умножение на 2 два раза
alert( 3 << 3 ); // 24, умножение на 2 три раза
// Конечно, следует иметь в виду, что побитовые операторы работают только с 32-битными числами, поэтому верхний порог такого «умножения» ограничен:

alert(10000000000 << 1); // -1474836480, отброшен крайний-левый бит
alert(10000000000 * 2); // 20000000000, обычное умножение

// >> (Правый битовый сдвиг, переносящий знак)
//
// Этот оператор сдвигает биты вправо, отбрасывая лишние. При этом слева добавляется копия крайнего-левого бита.
//
// Знак числа (представленный крайним-левым битом) при этом не меняется, так как новый крайний-левый бит имеет то же значение, что и исходном числе.
//
// Поэтому он назван «переносящим знак».
//
// Например, 9 >> 2 даст 2:
//
// 9 (по осн.10)
//   = 00000000000000000000000000001001 (по осн.2)
//                   --------------------------------
// 9 >> 2 (по осн.10)
//   = 00000000000000000000000000000010 (по осн.2)
//   = 2 (по осн.10)
// Операция >> 2 сдвинула вправо и отбросила два правых бита 01 и добавила слева две копии первого бита 00.
//
// Аналогично, -9 >> 2 даст -3:
//
// -9 (по осн.10)
//   = 11111111111111111111111111110111 (по осн.2)
//                    --------------------------------
// -9 >> 2 (по осн.10)
//   = 11111111111111111111111111111101 (по осн.2) = -3 (по осн.10)
// Здесь операция >> 2 сдвинула вправо и отбросила два правых бита 11 и добавила слева две копии первого бита 11. , Знак числа сохранён, так как крайний-левый (знаковый) бит сохранил значение 1.

// Правый сдвиг почти равен целочисленному делению на 2
// Битовый сдвиг >> N обычно имеет тот же результат, что и целочисленное деление на два N раз:

alert( 100 >> 1 ); // 50, деление на 2
alert( 100 >> 2 ); // 25, деление на 2 два раза
alert( 100 >> 3 ); // 12, деление на 2 три раза, целая часть от результата

// >>> (Правый сдвиг с заполнением нулями)
//
// Этот оператор сдвигает биты первого операнда вправо. Лишние биты справа отбрасываются. Слева добавляются нулевые биты.
//
// Знаковый бит становится равным 0, поэтому результат всегда положителен.
//
// Для неотрицательных чисел правый сдвиг с заполнением нулями >>> и правый сдвиг с переносом знака >> дадут одинаковый результат, т.к в обоих случаях слева добавятся нули.
//
// Для отрицательных чисел – результат работы разный. Например, -9 >>> 2 даст 1073741821, в отличие от -9 >> 2 (дает -3):
//
// -9 (по осн.10)
//   = 11111111111111111111111111110111 (по осн.2)
//                     --------------------------------
// -9 >>> 2 (по осн.10)
//   = 00111111111111111111111111111101 (по осн.2)
//   = 1073741821 (по осн.10)
