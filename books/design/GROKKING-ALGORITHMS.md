# Grokking Algorithms -  Aditya Bhargava

## Знакомство с алгоритмами

+ Алгоритм - последовательность действий

+ Некоторые задачи, решаемые алгоритмами
    + ИИ
    + Поиск данных
    + Оценка величин (времени)

### Бинарный поиск

+ На входе должны быть отсортированные данные

+ На каждом шаге отсекается половина данных граница которой не подходит под условие

+ Для поиска элемента в массиве размера - n, потребуется log(2)n шагов

+ Вычисление логарифма - операция обратная возведению в степень

+ Линейное время - O(n)

+ Логарифмическое время - O(log(2)n)

+ 'O' - специальная нотация, описывающая время работы алгоритма

+ Время выполнения растет при увеличении количества элементов с разной скоростью для разных алгоритмов

+ 'O' определяет насколько быстро растет время выполнения алгоритма

+ 'O' описывает худший случай времени выполнения алгоритма (максимальное количество итераций)

+ Самые распространенные примеры O по убыванию скорости
    + O(log(2)n) - логарифмическое время (бинарный поиск)
    + O(n) - линейное время (простой поиск)
    + O(n * log(2)n) (быстрая сортировка)
    + O(n^2) (сортировка выбором)
    + O(n!) (задача о коммивояжере (рассказано в след. разделе))

+ Скорость алгоритмов измеряется не в секундах, а в темпе роста количества операций
+ По сути формула описывает, насколько быстро возрастает время выполнения алгоритма с увеличением
    размера входных данных
+ Время выполнения алгоритмов выражается через O
+ Время выполенения O(log(2)n) быстрее чем O(n), а с увеличением размера списка, в котором ищется
    значение, оно становится намного быстрее

#### Задача о коммивояжере

+ Есть 5 городов, коммивояжер хочет объехать их все за самое короткое время, для вычисление этого
    необходимо перебрать все возможные варианты, а это - 5! = 120
+ При увеличении количества городов время выполнения будет очень возрастать по формуле - n!

#### Итог

+ Бинарный поиск работает намного быстрее простого
+ Прирост в скорости возрастает при увеличении входных данных
+ Скорость алгоритмов не измеряется в секундах
+ Время выполнения алгоритма измеряется ростом количества операций
+ Время выполнения алгоритма выражается как O

### Сортировка выбором

+ В этой главе
    + Структуры данных
        + Массивы
        + Связанный список
    + Сортировка выбором

#### Массивы и связанные списки

+ Для хранения списка одинаковых элементов используются массивы

+ Если мы не знаем заранее, сколько элемнтов будет в массиве то
    встает вопрос о добавлении новых элементов и автоматическом увеличении
    размера массива, что может быть затратным по части времени
+ Первое что приходит в голову создать массив с запасом
    + Недостатки этого решения
        + Лишнее место может не понадобиться
        + Существует вероятность, что увеличить размер все же понадобиться
+ Связанные списки решают проблему добавления новых элементов
+ При использовании связанных списков элементы могут быть
    разбросаны по памяти
+ В связанных списках элементы хранят в себе ссылки на другие элементы,
    следующий, предыдущий к примеру
+ Недостатки связанных списков
    + К примеру поиск последнего элемента требует обхода всего списка
        + В массиве мы бы просто обратились к последнему элементу по индексу
+ Если по списку надо прыгать с одного элемента на другой в произвольном порядке
    то лучше использовать массив
    + Обращение к каждому элементу в массиву происходит мгновенно

+ Время выполнения некоторых операций для массивов и связанных списков
    + O(1) - постоянное время выполнения
    + O(n) - линейное время выполнения
    + Массив
        + Чтение - О(1)
        + Вставка - О(n)
        + Удаление - О(n)
    + Связанный список
        + Чтение - О(n)
        + Вставка - О(1)
        + Удаление - О(1)

+ Вставка в середину
    + Список
        + Вставить элемент в определенное место в памяти
        + Вставить ссылку на следующий элемент после середины в новый элемент
        + Изменить ссылку в предыдущем серединном элементе на новый элемент
    + Массив
        + Переместить каждый элемент после серединного на одну ячейку дальше
        + Вставить элемент в освободившуюся ячейку
    + Список лучше подходит так как перемещение каждого элемента
        относительно долгий процесс
+ Удаление элемента
    + В этом случае список так же подходит лучше так как повторяется история
        с перемещением всех элементов массива

+ Необходимо заметить что операции вставки и удаления не подразумевают время
    для нахождения места где это необходимо сделать
+ На практике для связанных списков обычно сохраняют ссылки на первый и последний
    элемент, поэтому доступ к ним осуществляется за O(1)

+ Существует два вида доступа - последовательный и произвольный
    + Списки поддерживают только последовательный, т.е. необходимо перебрать все
        предыдущие элементы до искомого
    + Массивы же хороши тем, что поддерживают произвольный доступ

#### Сортировка выбором

+ Допустим у нас есть список произведений и количество раз которые они были воспроизведены
+ Нам нужно отсортировать их по убыванию для определения наиболее популярного
+ Мы используем следующий алгоритм
    + Создаем пустой массив
    + Проходим весь список каждый раз находя максимальный элемент и вставляя его
        в новый массив
+ Операция чтения элемента из массива = O(n)
+ Нам необходимо выполнить ее n количество раз
+ В результате мы получаем следующую оценку это алгоритма - O(n^2)

#### Итог

+ Память компьютера как шкаф с ящиками
+ Для хранения наборов элементов используются массивы и списки
+ В массиве все элементы хранятся друг за другом
+ В списке элементы распределяются в произвольных местах памяти, элементы имеют ссылки на другие
    элементы
+ Массивы обеспечивают быстрое чтение
+ Списки обеспечивают быстрые вставку и удаление
+ Все элементы массива имеют один тип

### Рекурсия

+ В этой главе
    + Рекурсия в алгоритмах
    + Разбиение задач на базовый и рекурсивный случаи

#### Понятие рекурсии

+ Задача для примера
    + Дано
        + Есть большая коробка, в которой есть еще коробки
        + Необходимо отыскать в этих коробках определенный предмет
    + Предполагаемый алгоритм решения
        + Сложить коробки в кучу
        + Пока в куче остаются коробки
            + Взять коробку и открыть
            + Если внутри есть искомое - завершить поиск
            + Если внутри есть коробка - положить ее в общую кучу
    + Рекурсивный алгоритм решения
        + Для каждого предмета в коробке
            + Если это искомое - поиск завершен
            + Если это коробка - выполнить перебор(какой делаем сейчас) 
                относительно найденной коробки

#### Базовый и рекурсивный случай

+ При использовании рекурсии важно определить условие для прерывания выполнения
    + Проверка условия прерывания называется базовый случай в этом контексте

#### Стек вызовов

+ Концепция стека вызовов играет важную роль при работе с рекурсией
+ Стек предоставляет всего два действия
    + Занесение - Push
    + Извлечение - Pull
+ Во время вызова функции из другой функции то вторая приостанавливает свое выполнение
    сохраняя состояние в стеке
+ Стек хранит в себе память для локальных переменных

#### Стек вызовов с рекурсией

+ При использовании рекурсии в стеке храняться все вызовы функции и их локлаьные данные
    что исключает необходимость хранить их как при использовании циклов

#### Итог

+ Функция вызывающая сама себя называется рекурсивной
+ В каждой рекурсивной функции должно быть два случая базовый и рекурсивный
    + Базовый случай необходим для прерывания рекурсии при определенных условиях
+ Стек поддерживает две операции
    + Извлечение
    + Занесение
+ Все вызовы функций сохраняются в стеке вызовов
+ Стек так же требует память

### Быстрая сортировка

+ В этой главе
    + Стратегия разделяй и властвуй
    + Алгоритм быстрой сортировки

#### Разделяй и властвуй

+ Пример задачи
    + Есть земельный участок размером n x m к примеру - 1680 х 640
    + Необходимо поделить его на равные квадратные части
    + Части должны быть максимально большими

+ Алгоритм решения задачи методом разделяй и властвуй
    + Сначала определяется базовый случай - простейщий случай из всех возможных
    + Задача делится или сокращается до тех пор пока не будет сведена
        к базовому случаю

+ Решение методом разделяй и властвуй
    + Простейщий случай задачи с земельным участком
        + Если одна сторона кратна другой то делением большую на меньшую мы
            вычислим количество максимально больших равных участков
    + Алгоритм
        + Если n не кратно m (1680 и 640)
            + Делим большее на меньшее 1680 / 640 = 2.625
            + Умножаем дробную часть на меньшее 2.625 x 640 = 400
            + Получаем неразрешеный участок размером - 640 x 400
            + Теперь размер для определения решения меньше и это нам на руку
        + Проделываем предыдущий шаг рекурсивно передавая каждый раз
            меньший размер
        + В определенный момент мы получим данные которое будут подходить
            под определение базового случая

+ Суммирование элементов массива

+ Решение для задачи о сумировании чисел в массиве
